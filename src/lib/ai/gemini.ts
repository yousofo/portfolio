import { Content, ContentListUnion, GoogleGenAI, Part } from "@google/genai";
import { MarkupKey } from "../db/enums";
import { saveHtmlAndCss } from "../db/saveHtmlAndCss";
import { IMarkup } from "../db/interfaces";
import { readHtmlAndCss } from "../db/readHtmlAndCss";

const systemPrompt = `
        You are a backend API.
        You are a strict HTML & CSS UI generation engine.
        You will be generating CODE for a NEXTJS app dynamic UI.

        Notes about the NEXTJS app:
        - It has a 2 main parts, an admin dashboard and a client interface.
        - The client interface is dynamic and can be prompted (to YOU) to be changed through the dashboard by the admin.
        - The client dynamic interface is dynamically generated by YOU and stored in a database.
        - It has predefined features like form submittion, items listing.
        - Only the client UI changes, the features are the same.
        - It will select html (generated by YOU) by predefined ids (that you assign to the html) to assign event listeners.
        - It will select inputs (generated by YOU) by predefined ids (that you assign to the html) to read values, apply validations and show error messages into other html (generated by YOU) predefined by ids (that you assign to the html).

        

        Dynamic App Features:
        1- Contact Form:
          - form id = 'contact-form'
          - 4 inputs (name, email, phone number, message) and their validation message containers:
            - name input id: contant-name-input
            - email input id: contant-email-input
            - phone input id: contant-phone-input
            - message input id: contant-message-input
            - name input validation message container id: contant-name-validation
            - email input validation message container id: contant-email-validation
            - phone input validation message container id: contant-phone-validation
            - message input validation message container id: contant-message-validation
          - the 'input' and 'validation message container' will have a 'invalid' class if invalid.
          - the submittion button must have an id = 'contact-submit-btn'

        generation keys:
        - contact-form = Dynamic App Feature 1
        - anything else = provide as the message says

        Response Rules:
        - Output Full (HTML & CSS) string for the required Feature, not only parts of it
        - Never explain
        - Never add comments
        - Never add markdown
        - Output RAW content only
        - NO markdown identifiers
        - NO triple backticks
        - Do not use fences.
        - Feel free to return huge size response
        - append <style> inside the returned html
        - No JavaScript syntax
        - No string concatenation
        - Return ONE string only
        - no multiple lines
        - no preceding or trailing anything
        - Always return this shape ONLY (string): <form id='contact-form'>...</form>

        HTML rules:
        - Semantic HTML only
        - No script tags

        CSS rules:
        - Scoped classes only
        - all generated style classes have scoped classes with GENERERATION KEY prefix as '.contact-form .name-input' 
        - div's parent has flex and justify-content: center and align-items: center so you need to take care width and height and responsiveness
        - stylish (extensive)
        - Mobile-first
        - No external libraries
      `;

// export async function configureGemini() {
//   const response = await gemini.models.generateContent({
//     config: {
//       responseSchema: "html",
//     },
//     contents: [
//       {
//,
//       },
//     ],
//     model: "gemini-3-flash-preview",
//   });

//   console.log(response.text);
// }

export async function generateGeminiUI(markupKey: MarkupKey, message: string): Promise<{ html: string; css: string }> {
  const gemini = new GoogleGenAI({
    apiKey:  process.env.GEMINI_API_KEY, //process.env.GEMINI_API_KEY,
  });

  const previousMarkup = await readHtmlAndCss(markupKey);

  const contents: Content[] = [
    {
      role: "system",
      parts: [
        {
          text: systemPrompt,
        },
      ],
    },
    {
      role: "system",
      parts: [
        {
          text: `
          //
          generation key: ${markupKey}
          //
          previous html: ${previousMarkup.html}
          //
          previous css: ${previousMarkup.css}
          `,
        },
      ],
    },
    {
      role: "user",
      parts: [
        {
          text: `
          generation key: ${markupKey}
          //
          message: ${message}
          //
          `,
        },
      ],
    },
  ];

  while (true) {
    const response = await gemini.models.generateContent({
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: "object",
          properties: {
            html: { type: "string" },
            css: { type: "string" },
          },
          required: ["html", "css"],
        },
      },
      contents,
      model: "gemini-3-flash-preview",
    });
    console.log("-----response------", response.text);

    if (response.sdkHttpResponse?.responseInternal?.status === 503) {
      await new Promise((r) => setTimeout(r, 1000));
      continue;
    }

    const markup: IMarkup = await JSON.parse(response.text!);

    await saveHtmlAndCss(markupKey, { html: markup.html, css: markup.css });

    return markup;
  }
}
